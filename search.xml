<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2F2018%2F07%2F07%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[创建一个对象123456var obj = new Object(); obj.name = '哈哈';obj.showName = function()&#123; console.log(obj.name);&#125;obj.showName(); 工厂模式12345678910111213function Factory(name)&#123; var obj = new Object(); //原料 obj.name = name; //加工 obj.showName = function()&#123; console.log(this.name); &#125; return obj; //出厂&#125;var a = Factory('豆豆'); a.showName();var b = Factory('图图'); b.showName();//其实就是简单的封装函数，整个过程像工厂的流水线，所以叫工厂方式 构造函数模式工厂方式无法识别创建的对象的类型。因为全部都是Object，没有区分度，不像Date、Array等，因此出现了构造函数模式。123456789101112function Factory(name)&#123; this.name = name; this.showName = function()&#123; console.log(this.name); &#125; &#125; var a =new Factory('豆豆'); a.showName();var b = new Factory('图图'); b.showName(); console.log(a.showName==b.showName); //false 构造函数为了区别于普通的函数要首字母大写，构造函数本身其实就是普通的函数，只是我们专门用它来实现了构造的功能，所以专门起了一个名字叫构造函数，任何函数都可以成为构造函数，这取决于你调用函数的方式，当使用了new的方式调用就成了构造函数。当用new去调用一个函数的时候，函数内的this会指向这个函数本身，不用new的话则指向window; 原型+构造模式函数构造每new一次，系统都会新创建一个内存，这两个对象各自有各自的地盘，但他们具有相同的功能，还不共用，所以就有了原型+构造模式。 原型：每个函数都有一个prototype属性，它是一个对象，也称作原型对象，我们可以把方法和属性写在它上面，而通过这个函数创建出来的实例对象，都能共享这个原型对象下的方法和属性。所以我们只需要把想要共享的东西放在函数的prototype下，不想共享的东西通过构造函数来创建就可以了。123456789101112function Factory(name)&#123; this.name = name;&#125;Factory.prototype.showName = function()&#123; console.log(this.name);&#125;var a =new Factory('豆豆');a.showName();var b = new Factory('图图');b.showName();console.log(a.showName==b.showName);//true //此处可见showName()方法是共享的，也就是说他们共用一个内存； _ proto _属性:123_proto_属性使同一个函数造出来的实例对象能共享这个函数的prototype下的方法和属性，每个实例化对象都有_proto_属性，保存了构造函数的原型对象的地址，通过这个属性就可以拥有原型对象下的所有属性和方法，_proto_属性实际就是实例化对象和原型对象之间的连接； 原型链每个函数都有原型对象，每个原型对象也可以是一个实例化对象，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，就形成了一条原型链。 原型链的访问规则：先在自身的下面寻找，再去一级一级的往原型链上找。1234567function Factory()&#123;&#125;Factory.prototype.num = 3;var a = new Factory();var b = new Factory();a.num =10;console.log(a.num); //10console.log(b.num); //3]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[减少HTTP请求次数建议尽可能的根据需要去合并静态资源图片、JavaScript代码和CSS文件，减少页面请求数，这样可以缩短页面首次访问的等待时间，另外也要尽量的避免重复资源，防止增加多余的请求。 减少HTTP请求大小除了减少请求资源数，也要减少每个http请求的大小。比如减少没必要的图片，JS，CSS以及HTML等，对文件进行压缩优化，开启GZIP压缩传输内容，缩短网络传输等待延迟。 减少对DOM的操作访问修改DOM元素都会导致浏览器重新计算页面的变化，所以一般建议尽量减少DOM数量和操作。 避免页面中空的href和src当link标签的href属性为空，或者script、img、iframe标签的src属性为空的时候，浏览器在渲染的过程中还是会把href和src的空内容进行加载，直到加载失败。这样就阻塞了页面中其他资源的下载进程，并且最后加载的内容是无效的，因此要尽量避免。 使用外部的JavaScript和CSS内联脚本或者样式可以减少HTTP请求，按理来说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。 每个用户产生的页面浏览量越少，内联脚本和样式的论据越强势。譬如一个用户每个月只访问你的网站一两次，那么这种情况下内联将会更好。而如果该用户能够产生很多页面浏览量，那么缓存的样式和脚本将会极大减少下载的时间，提交页面加载速度。 把CSS放到顶部网页上的资源加载时从上网下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。 把JS放到底部加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续的文件 ，所以就把js放在页面底部最后加载。 精简CSS和JS这里就涉及到css和js的压缩了。比如下面的新浪的一个css文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行css和js文件的压缩，如grunt，glup等。 删除重复的JS和CSS重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。 1234567$.ajax(&#123; url : &apos;url&apos;, dataType : &quot;json&quot;, cache: true, success : function(son, status)&#123;&#125;, error : function()&#123;&#125;&#125;) 使用GET来完成AJAX请求当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。 避免404比如外链的css、js文件出现问题返回404时，会破坏浏览器的并行加载。 减少Cookie的大小Cookie里面别塞那么多东西，因为每个请求都得带着他跑。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String方法]]></title>
    <url>%2F2018%2F06%2F23%2FString%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[转换为字符串字符串转换是最基础的要求和工作，你可以将任何类型的数据都转换为字符串1234var num= 19;console.log(num.toString()) //'19'console.log(String(num)) //'19'console.log(''+num) //'19' 分割字符串将一个字符串分割为多个字符串,以字符串数组的形式返回123var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.split(",")) //["I", "Love", "You", "Do", "you", "love", "me"]console.log(myStr.split(",",5)) //["I", "Love", "You", "Do", "you"] 字符串长度获取字符串的长度12var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.length) //25 查找字符串charAt()通过下标值找到对应的字符,没有就返回空字符123var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.charAt(2)) //Lconsole.log(myStr.charAt(26)) //'' charCodeAt()查找对应位置的字符编码值,没有就返回NaN123var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.charCodeAt(2)) //76console.log(myStr.charCodeAt(26)) //NaN search()根据字符查下标，没有返回-1；123var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.search('L')) //2console.log(myStr.search('a')) //-1 match()搭配正则使用，返回一个对象，其中index就是下标；123var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.match(/L/)) //["L", index: 2, input: "I,Love,You,Do,you,love,me", groups: undefined]console.log(myStr.match(/a/)) //null indexOf()与lastIndexOf()返回找到的第一个元素的索引，找不到就返回-1，indexOf() 正向搜索，lastIndexOf()反向搜索；12345var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.indexOf ('o')) //3console.log(myStr.indexOf ('a')) //-1console.log(myStr.lastIndexOf ('o')) //19console.log(myStr.lastIndexOf ('a')) //-1 截取字符串slice(a,b) a：起始位置;b：结束位置，没有这个参数默认为最后一个字符的位置.(返回值不包含结束位置的字符)12var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.slice(2,6)) //Love substring(a,b) a：起始位置;b：结束位置，没有这个参数默认为最后一个字符的位置.(返回值不包含结束位置的字符)12var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.substring(2,6)) //Love substring(a,b) a：起始位置;b：结束位置，没有这个参数默认为最后一个字符的位置.(返回值不包含结束位置的字符)123456var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.substring(2,6)) //Lovesubstring()和slice()的区别slice的参数可以为负数，slice的起始位置是不能大于结束位置的。substring的参数必需为正数，substring的起始位置可以大于结束位置，它会自动把两个位置调换。 substr(a,b) a：起始位置;b：截取的字符串长度（从指定的下标开始截取多少个字符），没有的话默认为起始位置到最后一个字符的长度.12var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.substr(2,8)) //Love,You 字符串大小写转换toLowerCase()方法将大写转换为小写；toUpperCase()方法将小写转换为大写；123var myStr = "I,Love,You,Do,you,love,me";console.log(myStr.toLowerCase()) //i,love,you,do,you,love,meconsole.log(myStr.toUpperCase()) //I,LOVE,YOU,DO,YOU,LOVE,ME 字符串首尾去空trim()方法去除字符串前后的空格；123var myStr = " I,Love,You,Do,you,love,me ";console.log(myStr) // I,Love,You,Do,you,love,me console.log(myStr.trim()) //I,Love,You,Do,you,love,me]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array方法]]></title>
    <url>%2F2018%2F06%2F16%2FArray%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[创建数组创建数组主要有构造函数和数组字面量两种方法:12var arr = new Array(); var arr = []; 对于构造函数，我们可以传递一个数值创建包含给定项数的数组：1var arr = new Array(3); //数组长度为3 也可以直接传递存放于数组中的值：1var arr = new Array("red","green","blue"); 数组转换为字符串join()转换时括号中是什么，返回值就用什么分割；1234var arr = ["red","green","blue"]; console.log(arr.toString()); //red,green,blue console.log(arr.join()); //red,green,blue console.log(arr.join('|')); //red|green|blue 数组中添加unshift在数组前增加内容，返回增加之后数组的长度；123var arr = [1, 2, 3]console.log(arr.unshift(4, 5, 0)); //6console.log(arr); //[4, 5, 0, 1, 2, 3] push在数组的后面增加内容，返回增加之后数组的长度；123var arr = [1, 2, 3]console.log(arr.push(4, 5, 0)); //6console.log(arr); //[1, 2, 3, 4, 5, 0] 数组中删除shift()删除数组首部的元素，返回被删除的元素；123var arr = [1, 2, 3]console.log(arr.shift()); //1console.log(arr); //[2, 3] pop()删除数组尾部的元素，返回被删除的元素；123var arr = [1, 2, 3]console.log(arr.pop()); //3console.log(arr); //[1, 2] 数组内容更改splice(开始下标，删除的长度，要增加的内容)，返回被删除的元素，可以实现增，删，改；增:123var arr = [1, 2, 3]arr.splice(3, 0, 4)console.log(arr) //[1, 2, 3, 4] 删：123var arr = [1, 2, 3]arr.splice(1, 1)console.log(arr) //[1, 3] 改：123var arr = [1, 2, 3]arr.splice(0, 1, 2)console.log(arr) //[2, 2, 3] 数组内容查找搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引，找不到就返回-1，indexOf() 正向搜索，lastIndexOf()反向搜索。1234var arr = [1, 2, 3, 4, 1, 2, 3];console.log(arr.indexOf(2)) //1console.log(arr.lastIndexOf(2)) //5console.log(arr.indexOf(5)) //-1 数组内容截取slice(开始下标，结束下标)（包括开始下标不包括结束下标），返回被截取到的元素。12var arr = [1, 2, 3]console.log(arr.slice(0,2)) //[1, 2] 数组排序reverse()将数组元素逆序排列，返回逆序后的数组。12var arr = [1, 2, 3]console.log(arr.reverse()) //[3, 2, 1] sort()按编码排序，返回排序后的数组。12var arr = [1, 2, 3, 10]console.log(arr.sort()) //[1, 10, 2, 3] 12345var arr = [1, 2, 3, 10]arr.sort(function(a, b) &#123; return a - b // b - a 数字类型从大到小排列&#125;)console.log(arr) //[1, 2, 3, 10] 数组遍历forEach()使用时有三个参数依次为：数组元素，元素的索引，数组本身。12345var arr = [1, 2, 3, 10]arr.forEach(function(v, i, a) &#123; //v——&gt;数组中的每一项，i——&gt;每一项对应的下标，a——&gt;原数组； a[i]=v+1; //数组中的每一项+1&#125;);console.log(arr) //[2, 3, 4, 11] map()方法会迭代数组中的每一个元素，并根据回调函数来处理每一个元素，最后返回一个新数组。（不会改变原始数组）123456var arr = [1, 2, 3, 10]var arr1=arr.map(function(w) &#123; return w*2 &#125;);console.log(arr) //[1, 2, 3, 10]console.log(arr1) //[2, 4, 6, 20] filter()方法如果返回值为 true ，则此项内容将被添加到一个作为返回值的数组中。（不会改变原始数组）123456var arr = [1, 2, 3, 10]var arr1=arr.filter(function(w) &#123; return w&lt;3&#125;);console.log(arr) //[1, 2, 3, 10]console.log(arr1) //[1, 2]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容问题]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[浏览器的兼容性问题，往往是个别浏览器对于一些标准的定义不一致导致的； html5shiv.js使用html5shiv.js解决 ie9 以下浏览器对 html5 新增标签不识别的问题。123&lt;!--[if lt IE 9]&gt;&lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; respond.js使用respond.js解决 ie9 以下浏览器不支持 CSS3 Media Query（媒体查询）的问题。123&lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt;&lt;!--[endif]--&gt; 使用reset.css做兼容reset.css 重置浏览器标签的样式表。因为浏览器的品种很多，每个浏览器的默认样式也是不同的，我们可以通过重置样式，然后再将它统一定义，就可以产生相同的显示效果。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;*:before,*:after &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, code,form, fieldset, legend, input, button, textarea, p, blockquote, th, td &#123; margin: 0; padding: 0;&#125;body &#123; background: #fff; color: #555; font-size: 14px; font-family: "Arial", "Microsoft YaHei", "黑体", "宋体", sans-serif;&#125;td, th, caption &#123; font-size: 14px;&#125;h1, h2, h3, h4, h5, h6 &#123; font-weight: normal; font-size: 100%;&#125;address, caption, cite, code, dfn, em, strong, th, var &#123; font-style: normal; font-weight: normal;&#125;a &#123; color: #555; text-decoration: none;&#125;a:hover &#123; text-decoration: underline;&#125;img &#123; border: none; vertical-align: middle;&#125;ol, ul, li &#123; list-style: none;&#125;input, textarea, select, button &#123; font: 14px "Arial", "Microsoft YaHei", "黑体", "宋体", sans-serif;&#125;table &#123; border-collapse: collapse;&#125;html &#123; overflow-y: scroll;&#125;.clearfix:before,.clearfix:after &#123; content: " "; display: inline-block; height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; *zoom: 1;&#125;/*公共类*/.fl &#123; float: left&#125;.fr &#123; float: right&#125;.al &#123; text-align: left&#125;.ac &#123; text-align: center&#125;.ar &#123; text-align: right&#125;.hide &#123; display: none&#125; 浏览器 CSS兼容前缀12345-o-transform:rotate(30deg); // Opera-ms-transform:rotate(30deg); // IE-moz-transform:rotate(30deg); // Firefox-webkit-transform:rotate(30deg); // Chrometransform:rotate(30deg); // 统一标识语句 IE9 以下浏览器使用透明度的兼容写法123opacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); //主要用来对图片进行透明处理 IE低版本使用 background-sizeCSS3 的background-size 可以定义背景图片的尺寸，但不支持ie6-ie8。可以引入background-size polyf解决问题，它的原理是创建一个 img 插入到容器中，并重新计算宽度、高度、left、top 等值，模拟 background-size 的效果。background-size-polyfill文件的git地址12-ms-behavior:url(backgroundsize.min.htc); behavior:url(backgroundsize.min.htc); 键盘事件 keyCode的兼容写法123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;input type="text" /&gt;&lt;p id="demo"&gt;&lt;/p&gt;&lt;script language="javascript"&gt; var ipt = document.getElementsByTagName('input')[0];function addHandler(element, type, handler)&#123; if (element.addEventListener)&#123; //标准的绑定事件监听函数的方法 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent)&#123; //IE浏览器绑定事件监听函数的方法 element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = handler; &#125; &#125; //可以获取每个按键的键码addHandler(ipt,"keydown",function(e)&#123; var e=window.event||e; //事件兼容写法 var key = e.keyCode || e.which || e.charCode; //IE只有keyCode属性，FireFox中有which和charCode属性，Opera中有keyCode和which属性，Chrome中有keyCode、which和charCode属性。 document.getElementById("demo").innerHTML = "键码值: " + key;&#125;) document.onkeydown=function mykeyDown(e)&#123; var e=window.event||e; var key = e.keyCode || e.which || e.charCode; if(key == 13)&#123;alert('已按下enter键');&#125; return; &#125; &lt;/script&gt; &lt;/body&gt;]]></content>
      <categories>
        <category>兼容</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS小结]]></title>
    <url>%2F2018%2F06%2F03%2Fcss%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[盒模型123盒子模型有两种，IE盒子模型、W3C盒子模型;盒子模型的构成部分：内容（content），内边距（padding），边框（border），外边距（margin）;两者的区别：IE盒子模型把border和padding也计算在content内； 常用选择器1234567891011121314151617181920id选择器（#id）;类选择器（.class);标签选择器（div）;相邻选择器（h1+p）；子选择器（ul&gt;li）；后代选择器（li a）；通配符（*）；属性选择器（a[href='']）;伪类选择器(p:first-of-type 选择属于其父元素的首个&lt;p&gt;元素的每个&lt;p&gt;元素p:last-of-type 选择属于其父元素的最后&lt;p&gt;元素的每个&lt;p&gt;元素p:only-of-type 选择属于其父元素唯一的&lt;p&gt;元素的每个&lt;p&gt;元素p:only-child 选择属于其父元素的唯一子元素的每个&lt;p&gt;元素p:nth-child(2) 选择属于其父元素的第二个子元素的每个&lt;p&gt;元素:after 在元素之前添加内容,也可以用来做清除浮动:before 在元素之后添加内容:enabled :disabled 控制表单控件的禁用状态:checked 单选框或复选框被选中) 优先级123优先级就近原则，同权重样式定义最近者为准；载入样式以最后载入的定位为准；优先级：!important &gt; id &gt; class &gt; tag &gt; *(通配符) display的值与作用12345678block:设定元素变为块级元素，占据一整行，可设置宽高；inline-block：设定元素为行内块元素，可设置宽高，一行能显示多个；inline：行内元素，不可设置宽高，一行可显示多个；none：设置元素不可见；flex：开启弹性布局；table：作为块级表格显示；list-item：像块级元素一样显示，并添加样式列表标记；inherit：从父元素继承display 属性的值 position的值与作用12345relative：相对定位，相对于正常位置进行定位absolute：绝对定位，相对于父元素中最近一个position不为 static（静态，无定位）定位；fixed：相对于浏览器窗口定位；static：默认，无定位；inherit：继承父元素的定位； CSS3的新特性123456789圆角：border-radius阴影：box-shadow文字阴影：text-shadow线性渐变：linear-gradienttransform:rotate(90deg) //旋转scale(0.5) //缩放translate(0px,-30px) //定位skew(-90deg,0deg) //倾斜 visibility:collapse与display:none1234两者都可以使元素隐藏不可见；区别：display:none渲染时不占据任何空间；visibility:hidden渲染时元素继续占据空间，只是内容不可见； 清除浮动的几种方式清除浮动是为了清除使用浮动的元素造成的影响；浮动的元素，高度会塌陷，对布局不利。解决方法：1.给父级div设置高度height2.使父级div也一起浮动3.给父级元素设置 overf:hidden;4.使用clearfix类名1234567891011.clearfix:before,.clearfix:after&#123; content:""; display:block; height:0; line-height:0; visibility:hidden; clear:both&#125;.clearfix&#123; *zoom:1;&#125; div的几种居中方式水平居中1.给div设置宽度，并使用margin：0 auto;123456 div&#123; width:100px; height:100px; margin:0 auto; background:hotpink;&#125; 2.使用绝对定位12345678div&#123; position:absolute； width:100px; height:100px; left:50%; margin-left:-50px; background-color:skyblue;&#125; 水平垂直居中1.使用绝对定位12345678910div&#123; position:absolute； width:100px; height:100px; left:50%; top:50%; margin-left:-50px; margin-top:-50px; background-color:red;&#125; 2.使用transform属性123456789div&#123; position:absolute； width:100px; height:100px; left:50%; top:50%; transform:translate(-50%,-50%) background-color:red;&#125; 3.使用弹性布局12345678910.container&#123; display:flex; align-items:center; justify-content:center;&#125;.container div&#123; width:100px; height:100px; background-color:hotpink;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎来到我的个人博客]]></title>
    <url>%2F2018%2F06%2F02%2F%E6%AC%A2%E8%BF%8E%E9%A1%B5%2F</url>
    <content type="text"></content>
  </entry>
</search>
